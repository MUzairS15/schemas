// Package patterns provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package patterns

import (
	"encoding/json"
	"fmt"

	externalRef2 "github.com/meshery/schemas/models/core"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for MesheryPatternCatalogDataClass.
const (
	Community MesheryPatternCatalogDataClass = "community"
	Official  MesheryPatternCatalogDataClass = "official"
	Verified  MesheryPatternCatalogDataClass = "verified"
)

// Defines values for MesheryPatternCatalogDataCompatibility.
const (
	Kubernetes MesheryPatternCatalogDataCompatibility = "kubernetes"
)

// Defines values for MesheryPatternCatalogDataType.
const (
	Deployment        MesheryPatternCatalogDataType = "Deployment"
	Observability     MesheryPatternCatalogDataType = "Observability"
	Resiliency        MesheryPatternCatalogDataType = "Resiliency"
	Scaling           MesheryPatternCatalogDataType = "Scaling"
	Security          MesheryPatternCatalogDataType = "Security"
	TrafficManagement MesheryPatternCatalogDataType = "Traffic-management"
	Troubleshooting   MesheryPatternCatalogDataType = "Troubleshooting"
	Workloads         MesheryPatternCatalogDataType = "Workloads"
)

// Defines values for MesheryPatternPatternFileComponentsModelStatus.
const (
	Duplicate MesheryPatternPatternFileComponentsModelStatus = "duplicate"
	Enabled   MesheryPatternPatternFileComponentsModelStatus = "enabled"
	Ignored   MesheryPatternPatternFileComponentsModelStatus = "ignored"
)

// Defines values for MesheryPatternPatternFileRelationshipsStatus.
const (
	Evaluating MesheryPatternPatternFileRelationshipsStatus = "evaluating"
	Invalid    MesheryPatternPatternFileRelationshipsStatus = "invalid"
	Valid      MesheryPatternPatternFileRelationshipsStatus = "valid"
)

// DeletePatternModel defines model for deletePatternModel.
type DeletePatternModel struct {
	ID   externalRef2.Id   `db:"id" json:"id"`
	Name externalRef2.Text `json:"name,omitempty"`
}

// MesheryPattern defines model for mesheryPattern.
type MesheryPattern struct {
	CatalogData *struct {
		// Class Published content is classifed by its support level. Content classes help you understand the origin and expected support level for each piece of content. It is important to note that the level of support may vary within each class, and you should exercise discretion when using community-contributed content. Content produced and fully supported by Meshery maintainers. This represents the highest level of support and is considered the most reliable. Content produced by partners and verified by Meshery maintainers. While not directly maintained by Meshery, it has undergone a verification process to ensure quality and compatibility. Content produced and supported by the respective project or organization responsible for the specific technology. This class offers a level of support from the project maintainers themselves. Content produced and shared by Meshery users. This includes a wide range of content, such as performance profiles, test results, filters, patterns, and applications. Community content may have varying levels of support and reliability.
		Class *MesheryPatternCatalogDataClass `json:"class,omitempty"`

		// Compatibility One or more models associated with this catalog item. For designs, a list of one or more models implicated by components within the design. For models, this is self-referential.
		Compatibility []MesheryPatternCatalogDataCompatibility `json:"compatibility"`

		// PatternCaveats Specific stipulations to consider and known behaviors to be aware of when using this design.
		PatternCaveats string `json:"pattern_caveats"`

		// PatternInfo Purpose of the design along with its intended and unintended uses.
		PatternInfo string `json:"pattern_info"`

		// PublishedVersion Tracks the specific content version that has been made available in the Catalog.
		PublishedVersion *string `json:"publishedVersion,omitempty"`

		// SnapshotURL Contains reference to the dark and light mode snapshots of the design.
		SnapshotURL *[]string `json:"snapshotURL,omitempty"`

		// Type Categorization of the type of design or operational flow depicted in this design.
		Type MesheryPatternCatalogDataType `json:"type"`
	} `json:"catalog_data,omitempty"`
	CreatedAt externalRef2.Time      `json:"created_at,omitempty"`
	ID        externalRef2.Id        `db:"id" json:"id"`
	Location  externalRef2.MapObject `json:"location,omitempty"`
	Name      externalRef2.Text      `json:"name,omitempty"`

	// PatternFile Designs are your primary tool for collaborative authorship of your infrastructure, workflow, and processes.
	PatternFile *struct {
		// Components Map of component instances to their corresponding component declarations
		Components MesheryPattern_PatternFile_Components `json:"components"`

		// Name Name of the design; a descriptive, but concise title for the design document.
		Name string `json:"name"`

		// Preferences Design-level preferences
		Preferences *struct {
			// Layers List of available layers
			Layers []string `json:"layers"`
		} `json:"preferences,omitempty"`

		// Relationships List of relationships between components
		Relationships []struct {
			// From ID (UUID) of the source component
			From openapi_types.UUID `json:"from"`

			// Kind Kind of the relationship
			Kind          string  `json:"kind"`
			SchemaVersion *string `json:"schemaVersion,omitempty"`

			// Status Status of the relationship
			Status MesheryPatternPatternFileRelationshipsStatus `json:"status"`

			// SubType Subtype of the relationship (optional)
			SubType *string `json:"subType,omitempty"`

			// To ID (UUID) of the target component
			To openapi_types.UUID `json:"to"`

			// Type Type of the relationship
			Type    string  `json:"type"`
			Version *string `json:"version,omitempty"`
		} `json:"relationships"`

		// SchemaVersion Specifies the version of the schema to which the design conforms.
		SchemaVersion string `json:"schemaVersion"`

		// Version Revision of the design as expressed by an auto-incremented, SemVer-compliant version number. May be manually set by a user or third-party system, but will always be required to be of version number higher than the previously defined version number.
		Version string `json:"version"`
	} `json:"pattern_file,omitempty"`
	UpdatedAt  externalRef2.Time `json:"updated_at,omitempty"`
	ID         externalRef2.Id   `db:"id" json:"id"`
	Visibility externalRef2.Text `json:"visibility,omitempty"`
}

// MesheryPatternCatalogDataClass Published content is classifed by its support level. Content classes help you understand the origin and expected support level for each piece of content. It is important to note that the level of support may vary within each class, and you should exercise discretion when using community-contributed content. Content produced and fully supported by Meshery maintainers. This represents the highest level of support and is considered the most reliable. Content produced by partners and verified by Meshery maintainers. While not directly maintained by Meshery, it has undergone a verification process to ensure quality and compatibility. Content produced and supported by the respective project or organization responsible for the specific technology. This class offers a level of support from the project maintainers themselves. Content produced and shared by Meshery users. This includes a wide range of content, such as performance profiles, test results, filters, patterns, and applications. Community content may have varying levels of support and reliability.
type MesheryPatternCatalogDataClass string

// MesheryPatternCatalogDataCompatibility defines model for MesheryPattern.CatalogData.Compatibility.
type MesheryPatternCatalogDataCompatibility string

// MesheryPatternCatalogDataType Categorization of the type of design or operational flow depicted in this design.
type MesheryPatternCatalogDataType string

// MesheryPattern_PatternFile_Components_Model_Metadata Metadata containing additional information associated with the model.
type MesheryPattern_PatternFile_Components_Model_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation,omitempty"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor,omitempty"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor,omitempty"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor,omitempty"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete,omitempty"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// MesheryPatternPatternFileComponentsModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type MesheryPatternPatternFileComponentsModelStatus string

// MesheryPattern_PatternFile_Components Map of component instances to their corresponding component declarations
type MesheryPattern_PatternFile_Components struct {
	// Component Component and it's configuration.
	Component struct {
		Configuration map[string]string `json:"configuration"`
		Kind          string            `json:"kind"`
		Version       string            `json:"version"`
	} `json:"component"`
	Metadata map[string]interface{} `json:"metadata"`

	// Model Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
	Model struct {
		// Category Category of the model.
		Category string `json:"category"`

		// Description Description of the model.
		Description *string `json:"description,omitempty"`

		// DisplayName Human-readable name for the model.
		DisplayName *string `json:"displayName,omitempty"`

		// Metadata Metadata containing additional information associated with the model.
		Metadata *MesheryPattern_PatternFile_Components_Model_Metadata `json:"metadata,omitempty"`

		// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
		Model *struct {
			// Version Version of the model as defined by the registrant.
			Version string `json:"version"`
		} `json:"model,omitempty"`

		// Name The unique name for the model within the scope of a registrant.
		Name       string                 `json:"name"`
		Registrant map[string]interface{} `json:"registrant"`

		// SchemaVersion Specifies the version of the schema used for the definition.
		SchemaVersion *string `json:"schemaVersion,omitempty"`

		// Status Status of model, including:
		// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
		// - maintenance: model is unavailable for a period of time.
		// - enabled: model is available for use for all users of this Meshery Server.
		// - ignored: model is unavailable for use for all users of this Meshery Server.
		Status *MesheryPatternPatternFileComponentsModelStatus `json:"status,omitempty"`

		// SubCategory Sub-category of the model.
		SubCategory *string `json:"subCategory,omitempty"`

		// Version Version of the model definition.
		Version string `json:"version"`
	} `json:"model"`
	Name                 string                        `json:"name"`
	SchemaVersion        string                        `json:"schemaVersion"`
	Version              string                        `json:"version"`
	AdditionalProperties map[string]openapi_types.UUID `json:"-"`
}

// MesheryPatternPatternFileRelationshipsStatus Status of the relationship
type MesheryPatternPatternFileRelationshipsStatus string

// MesheryPatternPage defines model for mesheryPatternPage.
type MesheryPatternPage struct {
	Page       int               `json:"page,omitempty"`
	PageSize   int               `json:"page_size,omitempty"`
	Patterns   *[]MesheryPattern `json:"patterns,omitempty"`
	ResultType string            `json:"resultType,omitempty"`
	TotalCount int               `json:"total_count,omitempty"`
}

// MesheryPatternResource defines model for mesheryPatternResource.
type MesheryPatternResource struct {
	CreatedAt externalRef2.Time `json:"created_at,omitempty"`
	Deleted   *bool             `json:"deleted,omitempty"`
	ID        externalRef2.Id   `db:"id" json:"id"`
	Name      externalRef2.Text `json:"name,omitempty"`
	Namepace  externalRef2.Text `json:"namepace,omitempty"`
	OamType   externalRef2.Text `json:"oam_type,omitempty"`
	Type      externalRef2.Text `json:"type,omitempty"`
	UpdatedAt externalRef2.Time `json:"updated_at,omitempty"`
	ID        externalRef2.Id   `db:"id" json:"id"`
}

// MesheryPatternResourcePage defines model for mesheryPatternResourcePage.
type MesheryPatternResourcePage struct {
	Page       int                       `json:"page,omitempty"`
	PageSize   int                       `json:"page_size,omitempty"`
	Resources  *[]MesheryPatternResource `json:"resources,omitempty"`
	ResultType string                    `json:"resultType,omitempty"`
	TotalCount int                       `json:"total_count,omitempty"`
}

// DesignShare defines model for designShare.
type DesignShare struct {
	ContentType string              `json:"content_type"`
	Emails      externalRef2.Emails `json:"emails"`
	ID          externalRef2.Id     `db:"id" json:"id"`
	Share       bool                `json:"share"`
}

// MesheryPatternDeleteRequestBody defines model for mesheryPatternDeleteRequestBody.
type MesheryPatternDeleteRequestBody struct {
	Patterns *[]DeletePatternModel `json:"patterns,omitempty"`
}

// MesheryPatternRequestBody defines model for mesheryPatternRequestBody.
type MesheryPatternRequestBody struct {
	Path        externalRef2.Text     `json:"path,omitempty"`
	PatternData *MesheryPattern       `json:"pattern_data,omitempty"`
	Save        *bool                 `json:"save,omitempty"`
	Url         externalRef2.Endpoint `json:"url,omitempty"`
}

// Getter for additional properties for MesheryPattern_PatternFile_Components_Model_Metadata. Returns the specified
// element and whether it was found
func (a MesheryPattern_PatternFile_Components_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for MesheryPattern_PatternFile_Components_Model_Metadata
func (a *MesheryPattern_PatternFile_Components_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for MesheryPattern_PatternFile_Components_Model_Metadata to handle AdditionalProperties
func (a *MesheryPattern_PatternFile_Components_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for MesheryPattern_PatternFile_Components_Model_Metadata to handle AdditionalProperties
func (a MesheryPattern_PatternFile_Components_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for MesheryPattern_PatternFile_Components. Returns the specified
// element and whether it was found
func (a MesheryPattern_PatternFile_Components) Get(fieldName string) (value openapi_types.UUID, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for MesheryPattern_PatternFile_Components
func (a *MesheryPattern_PatternFile_Components) Set(fieldName string, value openapi_types.UUID) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]openapi_types.UUID)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for MesheryPattern_PatternFile_Components to handle AdditionalProperties
func (a *MesheryPattern_PatternFile_Components) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["component"]; found {
		err = json.Unmarshal(raw, &a.Component)
		if err != nil {
			return fmt.Errorf("error reading 'component': %w", err)
		}
		delete(object, "component")
	}

	if raw, found := object["metadata"]; found {
		err = json.Unmarshal(raw, &a.Metadata)
		if err != nil {
			return fmt.Errorf("error reading 'metadata': %w", err)
		}
		delete(object, "metadata")
	}

	if raw, found := object["model"]; found {
		err = json.Unmarshal(raw, &a.Model)
		if err != nil {
			return fmt.Errorf("error reading 'model': %w", err)
		}
		delete(object, "model")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["schemaVersion"]; found {
		err = json.Unmarshal(raw, &a.SchemaVersion)
		if err != nil {
			return fmt.Errorf("error reading 'schemaVersion': %w", err)
		}
		delete(object, "schemaVersion")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]openapi_types.UUID)
		for fieldName, fieldBuf := range object {
			var fieldVal openapi_types.UUID
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for MesheryPattern_PatternFile_Components to handle AdditionalProperties
func (a MesheryPattern_PatternFile_Components) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["component"], err = json.Marshal(a.Component)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'component': %w", err)
	}

	object["metadata"], err = json.Marshal(a.Metadata)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'metadata': %w", err)
	}

	object["model"], err = json.Marshal(a.Model)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'model': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["schemaVersion"], err = json.Marshal(a.SchemaVersion)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'schemaVersion': %w", err)
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
